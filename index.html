<!DOCTYPE html>
<html>
<head>
    <style>
        .container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #ffe6f2;
            gap: 20px;
        }
        .bob-container {
            width: 200px;
            height: 200px;
        }
        .bob-gif {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        #heartCanvas {
            border: 2px solid #ffb3d9;
            border-radius: 10px;
            background: white;
        }
        .message {
            position: absolute;
            top: 20px;
            text-align: center;
            width: 100%;
            font-family: 'Arial', sans-serif;
            color: #ff4d94;
            font-size: 24px;
        }
    </style>
</head>
<body>
    <div class="message">Building Love, Just For You! ❤️</div>
    <div class="container">
        <div class="bob-container">
            <img src="bob-the-builder.gif" alt="Bob the Builder" class="bob-gif" id="bobGif">
        </div>
        <canvas id="heartCanvas" width="400" height="400"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('heartCanvas');
        const ctx = canvas.getContext('2d');
        
        // LEGO brick properties
        const brickWidth = 20;
        const brickHeight = 10;
        const brickColors = ['#ff6b6b', '#ff8585', '#ff9999', '#ff4d4d'];
        
        // Create a grid of points for the heart shape
        function isInHeart(x, y) {
            // Normalize coordinates
            const nx = (x - canvas.width/2) / 100;
            const ny = -(y - canvas.height/2) / 100;
            
            // Heart formula
            const heart = Math.pow(Math.pow(nx, 2) + Math.pow(ny - Math.sqrt(Math.abs(nx)), 2), 0.5);
            return heart <= 1.3;
        }
        
        // Brick class
        class Brick {
            constructor(x, y, row) {
                this.x = x;
                this.y = y;
                this.row = row;
                this.color = brickColors[Math.floor(Math.random() * brickColors.length)];
                this.scale = 0;
                this.built = false;
            }
            
            draw() {
                if (this.scale < 1) {
                    this.scale += 0.1;
                }
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.scale, this.scale);
                
                // Main brick body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.roundRect(-brickWidth/2, -brickHeight/2, brickWidth, brickHeight, 2);
                ctx.fill();
                
                // Brick studs
                ctx.fillStyle = '#ff3333';
                ctx.beginPath();
                ctx.arc(-5, -brickHeight/2, 2, 0, Math.PI * 2);
                ctx.arc(5, -brickHeight/2, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Brick shadow
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.fillRect(-brickWidth/2, brickHeight/3, brickWidth, brickHeight/6);
                
                ctx.restore();
            }
        }
        
        // Create bricks array
        const bricks = [];
        const gridSize = 8;
        
        // Generate brick positions row by row
        for (let row = 0; row < canvas.height; row += brickHeight) {
            for (let col = 0; col < canvas.width; col += brickWidth) {
                const x = col;
                const y = row;
                if (isInHeart(x, y)) {
                    bricks.push(new Brick(x, y, row));
                }
            }
        }
        
        // Sort bricks from bottom to top
        bricks.sort((a, b) => b.row - a.row);
        
        // Animation variables
        let currentBrick = 0;
        let buildDelay = 30;
        let lastBuildTime = 0;
        
        // Animation loop
        function animate(timestamp) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Build new brick if enough time has passed
            if (timestamp - lastBuildTime > buildDelay && currentBrick < bricks.length) {
                bricks[currentBrick].built = true;
                currentBrick++;
                lastBuildTime = timestamp;
            }
            
            // Draw all built bricks
            for (let i = 0; i < currentBrick; i++) {
                bricks[i].draw();
            }
            
            // Add sparkle effects
            if (currentBrick > 0) {
                const sparkleX = bricks[Math.max(0, currentBrick-1)].x;
                const sparkleY = bricks[Math.max(0, currentBrick-1)].y;
                drawSparkle(sparkleX, sparkleY, timestamp);
            }
            
            // Add love particles when heart is complete
            if (currentBrick === bricks.length) {
                drawLoveParticles(timestamp);
            }
            
            requestAnimationFrame(animate);
        }
        
        // Sparkle effect
        function drawSparkle(x, y, timestamp) {
            const sparkleSize = 2 + Math.sin(timestamp/200) * 1;
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(x, y, sparkleSize, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Love particles effect
        const particles = [];
        function drawLoveParticles(timestamp) {
            if (Math.random() < 0.1) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: canvas.height,
                    speed: 1 + Math.random() * 2,
                    size: 2 + Math.random() * 3
                });
            }
            
            ctx.fillStyle = '#ffccd5';
            particles.forEach((particle, index) => {
                particle.y -= particle.speed;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                
                if (particle.y < 0) particles.splice(index, 1);
            });
        }
        
        // Start animation
        animate(0);
    </script>
</body>
</html>
